#!python

"""
    Performance testing to find an acceptable K value + Attempting to create adaptive-K strategy
"""

import numpy as np 
import pandas as pd
import numcodecs
import zarr
from tqdm import tqdm
import allel
import sys
sys.path.append('src/')
from scipy.spatial.distance import squareform
from gen_ld_mat import est_kxp_mat

# ------- Data Directories ------ # 
DATA_DIR  = '/project2/jnovembre/data/external_public/geo_LD/'
VCF_1KG_DIR = '/project2/jnovembre/data/external_public/1kg_phase3/haps/'

#------ Rules ------ # 

rule filt_biallelic_AC_1kg:
    """
       Filter to biallelic SNPs in the 1000 Genomes Dataset (with a particular
       allele count filter)
    """
    input:
      vcf =  VCF_1KG_DIR + 'ALL.chr{CHROM}.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz'
    output:
      vcf = DATA_DIR  + 'ALL.chr{CHROM}.phase3_shapeit2_mvncall_integrated.20130502.biallelic_snps.ac{AC,\d+}.genotypes.vcf.gz',
      vcf_idx = DATA_DIR  + 'ALL.chr{CHROM}.phase3_shapeit2_mvncall_integrated.20130502.biallelic_snps.ac{AC,\d+}.genotypes.vcf.gz.tbi' 
    shell:
      """
      bcftools view -v snps -m2 -M2 -c {wildcards.AC}:minor {input.vcf} | bgzip -@4 > {output.vcf}    
      tabix -f {output.vcf}
      """
    
rule kxp_select_positions:
    """
       Generate k x p matrix for a chosen segment of a particular chromosome for individuals from a certain population 
    """
    input:
      vcf = rules.filt_biallelic_AC_1kg.output.vcf,
      popfile = VCF_1KG_DIR + 'integrated_call_samples_v3.20130502.ALL.panel' 
    output:
      ld_mat = 'data/performance_tests/chr{CHROM}_ac{AC,\d+}_K{K,\d+}_pos{POS1}_{POS2}_pop{POP}.npz'
    run:
       # Reading in vcf 
       callset = allel.read_vcf(input.vcf, region='{CHROM}:{POS1}-{POS2}', fields=['calldata/GT','samples','variants/POS'])
       # Creating genotype array
       gt = allel.GenotypeArray(callset['calldata/GT'])
       # Filtering out individuals of specific population
       panel = pd.read_csv(input.popfile, sep='\t', usecols=['sample', 'pop', 'super_pop'])
       pop_check = (panel['pop']=={POP})
       pop_indices = panel[pop_check].index.values
       pop_vec = panel['pop'].values
       pop_vec = pop_vec[pop_check]
       pop_gt = gt.take(pop_indices,axis=1)
       # Creating summed genotype matrix (2D)
       a = pop_gt.to_n_alt()
       snp_indices = []
       # Filtering out non-segregating sites in the specified population
       idx1 = ~np.all(a==0, axis=1)
       idx2 = ~np.all(a==1, axis=1)
       idx3 = ~np.all(a==2, axis=1)
       for i in range(idx1.shape[0]):
        if idx1[i]==True and idx2[i]==True and idx3[i]==True:
            snp_indices.append(i)
       # Creating arrays of indices and positions of segregating SNPs 
       snp_indices = np.array(snp_indices)
       pos = callset['variants/POS'][idx1 & idx2 & idx3]
       a = a[idx1 & idx2 & idx3]
       # Creating k x p matrix 
       ld_mat, alt_af = est_kxp_mat(a, pop_vec, wildcards.POP, int(wildcards.K))
       numpy.savez_compressed(output.ld_mat,ld_mat=ld_mat,snp_indices=snp_indices, pos=pos,alt_af=alt_af)
      
rule gen_pop_kxp_matrix:
    input:
       expand('data/performance_tests/chr{CHROM}_ac{AC}_K{K}_pos{POS1}_{POS2}_pop{POP}.npz', AC=5, POP=['CEU'], K=[100], CHROM=22, POS1=20000000, POS2=25000000)
